import { createComponent } from 'reakit-system/createComponent';
import { createHook } from 'reakit-system/createHook';
import '../Box/Box.js';
import { a as _objectWithoutPropertiesLoose, _ as _objectSpread2 } from '../_rollupPluginBabelHelpers-ce04ac6e.js';
import { useContext, useCallback } from 'react';
import 'reakit-utils/useForkRef';
import 'reakit-utils/isButton';
import 'reakit-utils/tabbable';
import 'reakit-utils/hasFocusWithin';
import 'reakit-warning';
import '../Tabbable/Tabbable.js';
import '../Clickable/Clickable.js';
import { useAllCallbacks } from 'reakit-utils/useAllCallbacks';
import 'reakit-utils/useSealedState';
import 'reakit-system/useCreateElement';
import 'reakit-utils/createOnKeyDown';
import '../Id/IdProvider.js';
import '../Id/IdState.js';
import '../Id/IdGroup.js';
import 'reakit-utils/applyState';
import '../CompositeState-e3303152.js';
import '../Composite/Composite.js';
import 'reakit-utils/useIsomorphicEffect';
import '../Group/Group.js';
import '../Id/Id.js';
import '../Composite/CompositeGroup.js';
import { getDocument } from 'reakit-utils/getDocument';
import 'reakit-utils/isTextField';
import 'reakit-utils/scrollIntoViewIfNeeded';
import 'reakit-utils/useLiveRef';
import '../setTextFieldValue-24aa34ae.js';
import { unstable_useCompositeItem } from '../Composite/CompositeItem.js';
import '../Composite/CompositeItemWidget.js';
import '../Disclosure/DisclosureState.js';
import 'reakit-utils/removeItemFromArray';
import '../Dialog/DialogState.js';
import '@popperjs/core';
import '../Popover/PopoverState.js';
import { u as useMenuState, M as MenuContext } from '../MenuState-5c873609.js';
import './MenuBarState.js';

// TODO: Find a better implementation
function isTouchDevice() {
  if (process.env.NODE_ENV === "test" || typeof window === "undefined") return false;
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}

function isExpandedDisclosure(element) {
  return element.hasAttribute("aria-controls") && element.getAttribute("aria-expanded") === "true";
}

function getRelatedElement(event) {
  if (event.relatedTarget instanceof Element) {
    return event.relatedTarget;
  }

  return null;
}

function hoveringInside(event) {
  var self = event.currentTarget;
  var relatedElement = getRelatedElement(event);
  if (!relatedElement) return false;
  return self.contains(relatedElement);
}

function hoveringExpandedMenu(event) {
  var self = event.currentTarget;
  var relatedElement = getRelatedElement(event);
  if (!relatedElement) return false;
  var document = getDocument(self);
  if (!isExpandedDisclosure(self)) return false;
  var menuId = self.getAttribute("aria-controls");
  var menu = document.getElementById(menuId);
  return menu === null || menu === void 0 ? void 0 : menu.contains(relatedElement);
}

function hoveringAnotherMenuItem(event, items) {
  return items === null || items === void 0 ? void 0 : items.some(function (item) {
    return item.ref.current === event.relatedTarget;
  });
}

var useMenuItem = createHook({
  name: "MenuItem",
  compose: unstable_useCompositeItem,
  useState: useMenuState,
  useProps: function useProps(options, _ref) {
    var htmlOnMouseEnter = _ref.onMouseEnter,
        htmlOnMouseLeave = _ref.onMouseLeave,
        htmlProps = _objectWithoutPropertiesLoose(_ref, ["onMouseEnter", "onMouseLeave"]);

    var menu = useContext(MenuContext);
    var menuRole = menu && menu.role;
    var onMouseEnter = useCallback(function (event) {
      if (menuRole === "menubar" || isTouchDevice()) return;
      var self = event.currentTarget;
      self.focus({
        preventScroll: true
      });
    }, [menuRole]);
    var onMouseLeave = useCallback(function (event) {
      var self = event.currentTarget;
      if (hoveringInside(event)) return; // If this item is a menu disclosure and mouse is leaving it to focus
      // its respective submenu, we don't want to do anything.

      if (hoveringExpandedMenu(event)) return; // On menu bars, hovering out of disclosure doesn't blur it.

      if (isExpandedDisclosure(self) && menuRole === "menubar") return; // Blur items on mouse out

      self.blur(); // Move focus to menu after blurring

      if (!hoveringAnotherMenuItem(event, options.items) && !isTouchDevice()) {
        var _options$move;

        (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, null);
      }
    }, [menuRole, options.move, options.items]);
    return _objectSpread2({
      role: "menuitem",
      onMouseEnter: useAllCallbacks(onMouseEnter, htmlOnMouseEnter),
      onMouseLeave: useAllCallbacks(onMouseLeave, htmlOnMouseLeave)
    }, htmlProps);
  }
});
var MenuItem = createComponent({
  as: "button",
  useHook: useMenuItem
});

export { MenuItem, useMenuItem };
