import { createComponent } from 'reakit-system/createComponent';
import { createHook } from 'reakit-system/createHook';
import '../Box/Box.js';
import { _ as _objectSpread2, a as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-ce04ac6e.js';
import { useRef, useEffect, useCallback, useMemo } from 'react';
import { useForkRef } from 'reakit-utils/useForkRef';
import 'reakit-utils/isButton';
import 'reakit-utils/tabbable';
import { hasFocusWithin } from 'reakit-utils/hasFocusWithin';
import { useWarning, warning } from 'reakit-warning';
import '../Tabbable/Tabbable.js';
import { useClickable } from '../Clickable/Clickable.js';
import { useAllCallbacks } from 'reakit-utils/useAllCallbacks';
import 'reakit-utils/useSealedState';
import { createOnKeyDown } from 'reakit-utils/createOnKeyDown';
import '../Id/IdProvider.js';
import '../Id/IdState.js';
import 'reakit-utils/applyState';
import { u as unstable_useCompositeState, g as getCurrentId } from '../CompositeState-e3303152.js';
import { unstable_useId } from '../Id/Id.js';
import { getDocument } from 'reakit-utils/getDocument';
import { isTextField } from 'reakit-utils/isTextField';
import { scrollIntoViewIfNeeded } from 'reakit-utils/scrollIntoViewIfNeeded';
import { useLiveRef } from 'reakit-utils/useLiveRef';
import { s as setTextFieldValue } from '../setTextFieldValue-24aa34ae.js';

function getWidget(item) {
  return item.querySelector("[data-composite-item-widget]");
}

function moveCaretToEnd(contentEditableElement) {
  var range = getDocument(contentEditableElement).createRange();
  range.selectNodeContents(contentEditableElement);
  range.collapse(false);
  var selection = getSelection();
  selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
  selection === null || selection === void 0 ? void 0 : selection.addRange(range);
}

var unstable_useCompositeItem = createHook({
  name: "CompositeItem",
  compose: [useClickable, unstable_useId],
  useState: unstable_useCompositeState,
  keys: ["stopId"],
  useOptions: function useOptions(options) {
    return _objectSpread2({}, options, {
      id: options.stopId || options.id,
      currentId: getCurrentId(options),
      unstable_clickOnSpace: options.unstable_hasActiveWidget ? false : options.unstable_clickOnSpace
    });
  },
  useProps: function useProps(options, _ref) {
    var _options$items;

    var htmlRef = _ref.ref,
        _ref$tabIndex = _ref.tabIndex,
        htmlTabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
        htmlOnFocus = _ref.onFocus,
        htmlOnKeyDown = _ref.onKeyDown,
        htmlOnClick = _ref.onClick,
        htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "tabIndex", "onFocus", "onKeyDown", "onClick"]);

    var ref = useRef(null);
    var id = options.id;
    var trulyDisabled = options.disabled && !options.focusable;
    var isCurrentItem = options.currentId === id;
    var isCurrentItemRef = useLiveRef(isCurrentItem);
    var item = (_options$items = options.items) === null || _options$items === void 0 ? void 0 : _options$items.find(function (i) {
      return i.id === id;
    });
    var shouldTabIndex = !options.unstable_virtual && !options.unstable_hasActiveWidget && isCurrentItem || // We don't want to set tabIndex="-1" when using CompositeItem as a
    // standalone component, without state props.
    !options.items;
    process.env.NODE_ENV !== "production" ? useWarning(!!options.stopId, "The `stopId` prop has been deprecated. Please, use the `id` prop instead.", ref) : void 0;
    useEffect(function () {
      var _options$registerItem;

      if (!id) return undefined;
      (_options$registerItem = options.registerItem) === null || _options$registerItem === void 0 ? void 0 : _options$registerItem.call(options, {
        id: id,
        ref: ref,
        disabled: !!trulyDisabled
      });
      return function () {
        var _options$unregisterIt;

        (_options$unregisterIt = options.unregisterItem) === null || _options$unregisterIt === void 0 ? void 0 : _options$unregisterIt.call(options, id);
      };
    }, [id, trulyDisabled, options.registerItem, options.unregisterItem]);
    useEffect(function () {
      var self = ref.current;

      if (!self) {
        process.env.NODE_ENV !== "production" ? warning(true, "Can't focus composite item component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite") : void 0;
        return;
      } // `moves` will be incremented whenever next, previous, up, down, first,
      // last or move have been called. This means that the composite item will
      // be focused whenever some of these functions are called. We're using
      // isCurrentItemRef instead of isCurrentItem because we don't want to
      // focus the item if isCurrentItem changes (and options.moves doesn't).


      if (options.unstable_moves && isCurrentItemRef.current) {
        self.focus({
          preventScroll: true
        });
        scrollIntoViewIfNeeded(self);
      }
    }, [options.unstable_moves]);
    var onFocus = useCallback(function (event) {
      var _options$setCurrentId;

      var target = event.target,
          currentTarget = event.currentTarget;
      if (!id || !currentTarget.contains(target)) return;
      (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, id); // When using aria-activedescendant, we want to make sure that the
      // composite container receives focus, not the composite item.
      // But we don't want to do this if the target is another focusable
      // element inside the composite item, such as CompositeItemWidget.

      if (options.unstable_virtual && currentTarget === target && options.baseId) {
        var composite = getDocument(target).getElementById(options.baseId);
        composite === null || composite === void 0 ? void 0 : composite.focus();
      }
    }, [id, options.setCurrentId, options.unstable_virtual, options.baseId]);
    var onKeyDown = useMemo(function () {
      return createOnKeyDown({
        onKeyDown: htmlOnKeyDown,
        stopPropagation: true,
        // We don't want to listen to focusable elements inside the composite
        // item, such as a CompositeItemWidget.
        shouldKeyDown: function shouldKeyDown(event) {
          return event.currentTarget === event.target;
        },
        keyMap: function keyMap() {
          // `options.orientation` can also be undefined, which means that
          // both `isVertical` and `isHorizontal` will be `true`.
          var isVertical = options.orientation !== "horizontal";
          var isHorizontal = options.orientation !== "vertical";
          var isGrid = !!(item === null || item === void 0 ? void 0 : item.groupId);

          var Delete = function Delete(event) {
            var widget = getWidget(event.currentTarget);

            if (widget && isTextField(widget)) {
              setTextFieldValue(widget, "");
            }
          };

          return {
            Delete: Delete,
            Backspace: Delete,
            ArrowUp: (isGrid || isVertical) && function () {
              var _options$up;

              return (_options$up = options.up) === null || _options$up === void 0 ? void 0 : _options$up.call(options);
            },
            ArrowRight: (isGrid || isHorizontal) && function () {
              var _options$next;

              return (_options$next = options.next) === null || _options$next === void 0 ? void 0 : _options$next.call(options);
            },
            ArrowDown: (isGrid || isVertical) && function () {
              var _options$down;

              return (_options$down = options.down) === null || _options$down === void 0 ? void 0 : _options$down.call(options);
            },
            ArrowLeft: (isGrid || isHorizontal) && function () {
              var _options$previous;

              return (_options$previous = options.previous) === null || _options$previous === void 0 ? void 0 : _options$previous.call(options);
            },
            Home: function Home(event) {
              if (!isGrid || event.ctrlKey) {
                var _options$first;

                (_options$first = options.first) === null || _options$first === void 0 ? void 0 : _options$first.call(options);
              } else {
                var _options$previous2;

                (_options$previous2 = options.previous) === null || _options$previous2 === void 0 ? void 0 : _options$previous2.call(options, true);
              }
            },
            End: function End(event) {
              if (!isGrid || event.ctrlKey) {
                var _options$last;

                (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
              } else {
                var _options$next2;

                (_options$next2 = options.next) === null || _options$next2 === void 0 ? void 0 : _options$next2.call(options, true);
              }
            },
            PageUp: function PageUp() {
              if (isGrid) {
                var _options$up2;

                (_options$up2 = options.up) === null || _options$up2 === void 0 ? void 0 : _options$up2.call(options, true);
              } else {
                var _options$first2;

                (_options$first2 = options.first) === null || _options$first2 === void 0 ? void 0 : _options$first2.call(options);
              }
            },
            PageDown: function PageDown() {
              if (isGrid) {
                var _options$down2;

                (_options$down2 = options.down) === null || _options$down2 === void 0 ? void 0 : _options$down2.call(options, true);
              } else {
                var _options$last2;

                (_options$last2 = options.last) === null || _options$last2 === void 0 ? void 0 : _options$last2.call(options);
              }
            }
          };
        }
      });
    }, [htmlOnKeyDown, item, options.orientation, options.next, options.previous, options.up, options.down, options.first, options.last]);
    var onCharacterKeyDown = useCallback(function (event) {
      if (event.currentTarget !== event.target) return;

      if (event.key.length === 1 && event.key !== " ") {
        var widget = getWidget(event.currentTarget);

        if (widget && isTextField(widget)) {
          widget.focus();
          var key = event.key; // Using RAF here because otherwise the key will be added twice
          // to the input when using roving tabindex

          window.requestAnimationFrame(function () {
            setTextFieldValue(widget, key);

            if (widget.isContentEditable) {
              moveCaretToEnd(widget);
            }
          });
        }
      }
    }, []); // Make sure the widget is focused on enter, space or click

    var onClick = useCallback(function (event) {
      var widget = getWidget(event.currentTarget);

      if (widget && !hasFocusWithin(widget)) {
        widget.focus();

        if (widget.isContentEditable) {
          moveCaretToEnd(widget);
        }
      }
    }, []);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      id: id,
      "aria-selected": options.unstable_virtual && isCurrentItem ? true : undefined,
      tabIndex: shouldTabIndex ? htmlTabIndex : -1,
      onFocus: useAllCallbacks(onFocus, htmlOnFocus),
      onKeyDown: useAllCallbacks(onCharacterKeyDown, onKeyDown),
      onClick: useAllCallbacks(onClick, htmlOnClick)
    }, htmlProps);
  }
});
var unstable_CompositeItem = createComponent({
  as: "button",
  useHook: unstable_useCompositeItem
});

export { unstable_CompositeItem, unstable_useCompositeItem };
