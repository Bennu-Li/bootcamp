import { createComponent } from 'reakit-system/createComponent';
import { createHook } from 'reakit-system/createHook';
import '../Box/Box.js';
import { a as _objectWithoutPropertiesLoose, _ as _objectSpread2 } from '../_rollupPluginBabelHelpers-ce04ac6e.js';
import { useContext, useRef, useMemo, useCallback } from 'react';
import { useForkRef } from 'reakit-utils/useForkRef';
import 'reakit-utils/isButton';
import 'reakit-utils/tabbable';
import { hasFocusWithin } from 'reakit-utils/hasFocusWithin';
import 'reakit-warning';
import '../Tabbable/Tabbable.js';
import '../Clickable/Clickable.js';
import '../Button/Button.js';
import { useAllCallbacks } from 'reakit-utils/useAllCallbacks';
import 'reakit-utils/useSealedState';
import 'reakit-system/useCreateElement';
import { createOnKeyDown } from 'reakit-utils/createOnKeyDown';
import '../Id/IdProvider.js';
import '../Id/IdState.js';
import '../Id/IdGroup.js';
import 'reakit-utils/applyState';
import '../CompositeState-e3303152.js';
import '../Composite/Composite.js';
import 'reakit-utils/useIsomorphicEffect';
import '../Group/Group.js';
import '../Id/Id.js';
import '../Composite/CompositeGroup.js';
import 'reakit-utils/getDocument';
import 'reakit-utils/isTextField';
import 'reakit-utils/scrollIntoViewIfNeeded';
import 'reakit-utils/useLiveRef';
import '../setTextFieldValue-24aa34ae.js';
import '../Composite/CompositeItem.js';
import '../Composite/CompositeItemWidget.js';
import '../Disclosure/DisclosureState.js';
import 'reakit-utils/removeItemFromArray';
import '../Dialog/DialogState.js';
import '../Disclosure/Disclosure.js';
import '../Dialog/DialogDisclosure.js';
import '@popperjs/core';
import '../Popover/PopoverState.js';
import { u as useMenuState, M as MenuContext } from '../MenuState-5c873609.js';
import './MenuBarState.js';
import { usePopoverDisclosure } from '../Popover/PopoverDisclosure.js';

var noop = function noop() {};

var useMenuButton = createHook({
  name: "MenuButton",
  compose: usePopoverDisclosure,
  useState: useMenuState,
  useProps: function useProps(options, _ref) {
    var htmlRef = _ref.ref,
        htmlOnClick = _ref.onClick,
        htmlOnKeyDown = _ref.onKeyDown,
        htmlOnFocus = _ref.onFocus,
        htmlOnMouseEnter = _ref.onMouseEnter,
        htmlOnMouseDown = _ref.onMouseDown,
        htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "onClick", "onKeyDown", "onFocus", "onMouseEnter", "onMouseDown"]);

    var parent = useContext(MenuContext);
    var ref = useRef(null);
    var hasPressedMouse = useRef(false);

    var _options$placement$sp = options.placement.split("-"),
        dir = _options$placement$sp[0];

    var hasParent = Boolean(parent);
    var parentIsMenuBar = parent && parent.role === "menubar";
    var onKeyDown = useMemo(function () {
      return createOnKeyDown({
        onKeyDown: htmlOnKeyDown,
        stopPropagation: function stopPropagation(event) {
          return event.key !== "Escape";
        },
        onKey: options.show,
        keyMap: function keyMap() {
          // prevents scroll jump
          var first = function first() {
            return setTimeout(options.first);
          };

          return {
            Escape: options.hide,
            Enter: hasParent && first,
            " ": hasParent && first,
            ArrowUp: dir === "top" || dir === "bottom" ? options.last : false,
            ArrowRight: dir === "right" && first,
            ArrowDown: dir === "bottom" || dir === "top" ? first : false,
            ArrowLeft: dir === "left" && first
          };
        }
      });
    }, [htmlOnKeyDown, dir, hasParent, options.show, options.hide, options.first, options.last]);
    var onMouseEnter = useCallback(function (event) {
      // MenuButton's don't do anything on mouse over when they aren't
      // cointained within a Menu/MenuBar
      if (!parent) return;
      var self = event.currentTarget;

      if (parentIsMenuBar) {
        var _parent$ref$current;

        // if MenuButton is an item inside a MenuBar, it'll only open
        // if there's already another sibling expanded MenuButton
        var subjacentOpenMenu = (_parent$ref$current = parent.ref.current) === null || _parent$ref$current === void 0 ? void 0 : _parent$ref$current.querySelector("[aria-expanded='true']");

        if (subjacentOpenMenu) {
          self.focus();
        }
      } else {
        // If it's in a Menu, open after a short delay
        // TODO: Make the delay a prop?
        setTimeout(function () {
          if (hasFocusWithin(self)) {
            var _options$show;

            (_options$show = options.show) === null || _options$show === void 0 ? void 0 : _options$show.call(options);
          }
        }, 200);
      }
    }, [parent, parentIsMenuBar, options.show]);
    var onMouseDown = useCallback(function () {
      // When in menu bar, the menu button can be activated either by focus
      // or click, but we don't want both to trigger sequentially.
      // Otherwise, onClick would toggle (hide) the menu right after it got
      // shown on focus.
      hasPressedMouse.current = true;
    }, []);
    var onFocus = useCallback(function () {
      if (parentIsMenuBar && !hasPressedMouse.current) {
        var _options$show2;

        (_options$show2 = options.show) === null || _options$show2 === void 0 ? void 0 : _options$show2.call(options);
      }
    }, [parentIsMenuBar, options.show]); // If disclosure is rendered as a menu bar item, it's toggable
    // That is, you can click on the expanded disclosure to close its menu.

    var onClick = useCallback(function () {
      if (hasParent && !parentIsMenuBar) {
        var _options$show3;

        (_options$show3 = options.show) === null || _options$show3 === void 0 ? void 0 : _options$show3.call(options);
      } else {
        var _options$toggle;

        (_options$toggle = options.toggle) === null || _options$toggle === void 0 ? void 0 : _options$toggle.call(options);
      }

      hasPressedMouse.current = false;
    }, [hasParent, parentIsMenuBar, options.show, options.toggle]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      "aria-haspopup": "menu",
      onKeyDown: onKeyDown,
      onMouseEnter: useAllCallbacks(onMouseEnter, htmlOnMouseEnter),
      onMouseDown: useAllCallbacks(onMouseDown, htmlOnMouseDown),
      onFocus: useAllCallbacks(onFocus, htmlOnFocus),
      onClick: useAllCallbacks(onClick, htmlOnClick)
    }, htmlProps);
  },
  useComposeOptions: function useComposeOptions(options) {
    return _objectSpread2({}, options, {
      // Toggling is handled by MenuButton
      toggle: noop
    });
  }
});
var MenuButton = createComponent({
  as: "button",
  useHook: useMenuButton
});

export { MenuButton, useMenuButton };
