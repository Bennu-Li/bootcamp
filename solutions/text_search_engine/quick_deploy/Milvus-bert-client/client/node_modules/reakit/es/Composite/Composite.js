import { createComponent } from 'reakit-system/createComponent';
import { createHook } from 'reakit-system/createHook';
import '../Box/Box.js';
import { _ as _objectSpread2, a as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-ce04ac6e.js';
import { useRef, useCallback, useEffect, useMemo } from 'react';
import { useForkRef } from 'reakit-utils/useForkRef';
import 'reakit-utils/isButton';
import 'reakit-utils/tabbable';
import 'reakit-utils/hasFocusWithin';
import { warning, useWarning } from 'reakit-warning';
import { useTabbable } from '../Tabbable/Tabbable.js';
import { useAllCallbacks } from 'reakit-utils/useAllCallbacks';
import 'reakit-utils/useSealedState';
import { useCreateElement } from 'reakit-system/useCreateElement';
import { createOnKeyDown } from 'reakit-utils/createOnKeyDown';
import '../Id/IdProvider.js';
import '../Id/IdState.js';
import { unstable_useIdGroup } from '../Id/IdGroup.js';
import 'reakit-utils/applyState';
import { u as unstable_useCompositeState, g as getCurrentId, f as findFirstEnabledItem, a as flatten, r as reverse, b as groupItems } from '../CompositeState-e3303152.js';

var validCompositeRoles = ["combobox", "grid", "tablist", "listbox", "menu", "menubar", "toolbar", "radiogroup", "tree", "treegrid"];

function canProxyKeyboardEvent(event) {
  if (event.target !== event.currentTarget) return false;
  if (event.metaKey) return false;
  if (event.key === "Tab") return false;
  return true;
}

function useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {
  return useCallback(function (event) {
    if (virtual && canProxyKeyboardEvent(event)) {
      var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;

      if (currentElement) {
        currentElement.dispatchEvent(new KeyboardEvent(event.type, event)); // The event will be triggered on the composite item and then
        // propagated up to this composite element again, so we can pretend
        // that it wasn't called on this component in the first place.

        if (event.currentTarget.contains(currentElement)) {
          event.stopPropagation();
          event.preventDefault();
          return;
        }
      }
    }

    htmlEventHandler === null || htmlEventHandler === void 0 ? void 0 : htmlEventHandler(event);
  }, [virtual, currentItem, htmlEventHandler]);
}

function findFirstEnabledItemInTheLastRow(items) {
  return findFirstEnabledItem(flatten(reverse(groupItems(items))));
}

var unstable_useComposite = createHook({
  name: "Composite",
  compose: [unstable_useIdGroup, useTabbable],
  useState: unstable_useCompositeState,
  useOptions: function useOptions(options) {
    return _objectSpread2({}, options, {
      currentId: getCurrentId(options)
    });
  },
  useProps: function useProps(options, _ref) {
    var _options$items;

    var htmlRef = _ref.ref,
        htmlOnFocus = _ref.onFocus,
        htmlOnKeyDown = _ref.onKeyDown,
        htmlOnKeyUp = _ref.onKeyUp,
        htmlProps = _objectWithoutPropertiesLoose(_ref, ["ref", "onFocus", "onKeyDown", "onKeyUp"]);

    var ref = useRef(null);
    var currentItem = (_options$items = options.items) === null || _options$items === void 0 ? void 0 : _options$items.find(function (item) {
      return item.id === options.currentId;
    });
    var onKeyDown = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDown);
    var onKeyUp = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUp);
    useEffect(function () {
      var self = ref.current;

      if (!self) {
        process.env.NODE_ENV !== "production" ? warning(true, "Can't focus composite component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite") : void 0;
        return;
      }

      if (options.unstable_moves && !currentItem) {
        self.focus();
      }
    }, [options.unstable_moves, currentItem]);
    var onFocus = useCallback(function (event) {
      if (event.target !== event.currentTarget) return;

      if (options.unstable_virtual) {
        if (!currentItem || !options.items) return;
        var hasItemWithFocus = options.items.some(function (item) {
          return item.ref.current === event.relatedTarget;
        }); // It means that the composite element has been focused while the
        // composite item has not. For example, by clicking on the composite
        // element without touching any item, or by tabbing into the
        // composite element. In this case, we want to trigger focus on the
        // item, just like it would happen with roving tabindex.
        // When it receives focus, the composite item will put focus back on
        // the composite element, in which case event.target will be
        // different from event.currentTarget.

        if (!hasItemWithFocus) {
          var _currentItem$ref$curr;

          (_currentItem$ref$curr = currentItem.ref.current) === null || _currentItem$ref$curr === void 0 ? void 0 : _currentItem$ref$curr.focus();
        }
      } else {
        var _options$setCurrentId;

        // When the roving tabindex composite gets intentionally focused (for
        // example, by clicking directly on it, and not on an item), we make
        // sure to set the current id to null (which means the composite
        // itself is focused).
        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);
      }
    }, [options.unstable_virtual, options.items, currentItem, options.setCurrentId]);
    var onMove = useMemo(function () {
      return createOnKeyDown({
        stopPropagation: true,
        shouldKeyDown: function shouldKeyDown(event) {
          return event.target === event.currentTarget && options.currentId === null;
        },
        keyMap: function keyMap() {
          var _options$groups;

          var isVertical = options.orientation !== "horizontal";
          var isHorizontal = options.orientation !== "vertical";
          var isGrid = !!((_options$groups = options.groups) === null || _options$groups === void 0 ? void 0 : _options$groups.length);

          var up = function up() {
            if (isGrid) {
              var item = findFirstEnabledItemInTheLastRow(options.items);

              if (item === null || item === void 0 ? void 0 : item.id) {
                var _options$move;

                (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item.id);
              }
            } else {
              var _options$last;

              (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
            }
          };

          return {
            ArrowUp: (isGrid || isVertical) && up,
            ArrowRight: (isGrid || isHorizontal) && options.first,
            ArrowDown: (isGrid || isVertical) && options.first,
            ArrowLeft: (isGrid || isHorizontal) && options.last,
            Home: options.first,
            End: options.last,
            PageUp: options.first,
            PageDown: options.last
          };
        }
      });
    }, [options.currentId, options.orientation, options.groups, options.items, options.last, options.first, options.move]);
    return _objectSpread2({
      ref: useForkRef(ref, htmlRef),
      id: options.baseId,
      onFocus: useAllCallbacks(onFocus, htmlOnFocus),
      onKeyDown: useAllCallbacks(onMove, onKeyDown),
      onKeyUp: onKeyUp,
      "aria-activedescendant": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || undefined : undefined
    }, htmlProps);
  },
  useComposeProps: function useComposeProps(options, htmlProps) {
    htmlProps = unstable_useIdGroup(options, htmlProps, true);
    var tabbableHTMLProps = useTabbable(options, htmlProps, true);

    if (options.unstable_virtual || options.currentId === null) {
      // Composite will only be tabbable by default if the focus is managed
      // using aria-activedescendant, which requires DOM focus on the container
      // element (the composite)
      return tabbableHTMLProps;
    }

    return _objectSpread2({}, htmlProps, {
      ref: tabbableHTMLProps.ref
    });
  }
});
var unstable_Composite = createComponent({
  as: "div",
  useHook: unstable_useComposite,
  useCreateElement: function useCreateElement$1(type, props, children) {
    process.env.NODE_ENV !== "production" ? useWarning(validCompositeRoles.indexOf(props.role) === -1, "You should provide a valid `role` attribute to composite components.", "See https://reakit.io/docs/composite") : void 0;
    process.env.NODE_ENV !== "production" ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/composite") : void 0;
    return useCreateElement(type, props, children);
  }
});

export { unstable_Composite, unstable_useComposite };
